package gogen

import (
	"bufio"
	"bytes"
	"fmt"
	"go/ast"
	"go/parser"
	"go/printer"
	"go/token"
	"go/types"
	"path"
	"path/filepath"
	"sort"
	"strings"

	"github.com/spf13/afero"
)

func NewGenerator(os ...Option) *Generator {
	opts := options{}
	for _, o := range os {
		o(&opts)
	}
	return &Generator{
		opts: opts,
	}
}

type Option func(opts *options)

func ModulePath(path string) Option {
	return func(opts *options) {
		opts.modPath = path
	}
}

type options struct {
	modPath string
}

type Generator struct {
	opts  options
	files []*File
}

var goUniverseScope = func() *Scope {
	reservedNames := stringSet{}
	for _, name := range types.Universe.Names() {
		reservedNames.Add(name)
	}
	return &Scope{
		parent:        nil,
		reservedNames: reservedNames,
	}
}()

// NewFile returns file for given path and import path.
func (g *Generator) NewFile(path string, importPath ImportPath) *File {
	f := &File{
		g:            g,
		path:         path,
		importPath:   importPath,
		importToName: map[ImportPath]string{},
		fileScope:    goUniverseScope.Nested(),
		buf:          bytes.Buffer{},
	}
	g.files = append(g.files, f)
	return f
}

func (g *Generator) Files() []*File { return g.files }
func (g *Generator) WriteFiles(fs afero.Fs) error {
	for _, f := range g.files {
		if f.skipped {
			continue
		}
		err := f.WriteFile(fs)
		if err != nil {
			return fmt.Errorf("file %s: %w", f.path, err)
		}
	}
	return nil
}

type File struct {
	g          *Generator
	path       string
	importPath ImportPath
	// TODO(skipor): support '_' and '.' imports
	importToName map[ImportPath]string
	// fileScope contains import names, global variable names, names that wanted to be same in all func scopes (receiver names for example)
	fileScope *Scope
	skipped   bool
	buf       bytes.Buffer
}

func (f *File) Path() string {
	return f.path
}

func (f *File) Content() ([]byte, error) {
	// TODO(skipor): optional: `// Code generated by ` + f.g.name + `. DO NOT EDIT.`
	file, err := parseFile(f.bufWithImports())
	if err != nil {
		return nil, fmt.Errorf("unparsable Go code: %w", err)
	}

	content, err := printFile(file)
	if err != nil {
		return nil, fmt.Errorf("reformat: %w", err)
	}
	return content, nil

}

func (f *File) bufWithImports() []byte {
	raw := f.buf.Bytes()
	if len(f.importToName) == 0 {
		return raw
	}

	out := &bytes.Buffer{}
	s := bufio.NewScanner(bytes.NewReader(raw))
	var packageNameLineFound bool
	for s.Scan() {
		line := s.Bytes()
		out.Write(line)
		out.WriteByte('\n')
		if bytes.HasPrefix(line, packageNameLinePrefix) {
			packageNameLineFound = true
			break
		}
	}
	if !packageNameLineFound {
		// Parse will fail with error.
		return raw
	}

	p := func(format string, args ...interface{}) { _, _ = fmt.Fprintf(out, format, args...) }

	type namePkg struct {
		name string
		pkg  ImportPath
	}
	var blocks [3][]namePkg
	for pkg, name := range f.importToName {
		b := f.importBlockKind(pkg)
		blocks[b] = append(blocks[b], namePkg{
			name: name,
			pkg:  pkg,
		})
	}

	p("\n")
	p("import (\n")
	for _, b := range blocks {
		if len(b) == 0 {
			continue
		}
		sort.Slice(b, func(i, j int) bool {
			return b[i].pkg < b[j].pkg
		})
		for _, np := range b {
			p("\t %s \"%s\"\n", np.name, np.pkg)
		}
		p("\n")
	}
	_ = out.UnreadByte() // Final '\n'
	p(")\n")
	p("\n")

	for s.Scan() {
		line := s.Bytes()
		out.Write(line)
		out.WriteByte('\n')
	}

	return out.Bytes()
}

type importBlockKind int

const (
	stdlibImportBlockKind     importBlockKind = 0
	thirdPartyImportBlockKind importBlockKind = 1
	moduleImportBlockKind     importBlockKind = 2
)

func (f *File) importBlockKind(pkg ImportPath) importBlockKind {
	firstPart := strings.SplitN(string(pkg), "/", 2)[0]
	if !strings.Contains(firstPart, ".") {
		return stdlibImportBlockKind
	}
	modPath := f.g.opts.modPath
	if modPath == "" {
		const modulePathParts = 3
		parts := strings.SplitN(string(f.importPath), "/", modulePathParts+1)
		if len(parts) > modulePathParts {
			parts = parts[:modulePathParts]
		}
		modPath = strings.Join(parts, "/")
	}
	isModuleImport := strings.HasPrefix(string(pkg), modPath) && (len(pkg) == len(modPath) || pkg[len(modPath)] == '/')
	if isModuleImport {
		return moduleImportBlockKind
	}
	return thirdPartyImportBlockKind
}

var packageNameLinePrefix = []byte("package ")

// Skip may be used to skip file from generation.
func (f *File) Skip()         { f.skipped = true }
func (f *File) Skipped() bool { return f.skipped }

func (f *File) WriteFile(FS afero.Fs) error {
	if f.Skipped() {
		return fmt.Errorf("file skipped")
	}
	content, err := f.Content()
	if err != nil {
		return fmt.Errorf("render: %w", err)
	}

	dir, _ := filepath.Split(f.path)
	if !(dir == "" || dir == ".") {
		err := FS.MkdirAll(dir, 755)
		if err != nil {
			return fmt.Errorf("make dir all: %w", err)
		}
	}

	err = afero.WriteFile(FS, f.path, content, 0644)
	if err != nil {
		return fmt.Errorf("write: %w", err)
	}
	return nil
}

func (f *File) P(args ...interface{}) *File {
	for _, arg := range args {
		switch arg := arg.(type) {
		case Ident:
			_, _ = f.buf.WriteString(f.QualifiedIdent(arg))
		case []byte:
			_, _ = f.buf.Write(arg)
		case string:
			_, _ = f.buf.WriteString(arg)
		default:
			_, _ = fmt.Fprint(&f.buf, arg)
		}
	}
	return f
}

func (f *File) L(args ...interface{}) *File {
	f.P(args...)
	f.buf.WriteByte('\n')
	return f
}

func (f *File) Write(p []byte) (int, error) {
	return f.buf.Write(p)
}

func (f *File) Buffer() *bytes.Buffer {
	return &f.buf
}

func (f *File) QualifiedIdent(i Ident) string {
	return f.QualifiedImportPath(i.ImportPath) + "." + i.Name
}

func (f *File) QualifiedImportPath(path ImportPath) string {
	f.Import(path)
	return f.importToName[path]
}

func (f *File) Import(p ImportPath) {
	_, ok := f.importToName[p]
	if ok {
		return
	}
	f.importToName[p] = f.uniqueImportName(p)
}

func (f *File) Scope() *Scope {
	return f.fileScope
}

func (f *File) NewFuncScope() *Scope {
	return &Scope{
		parent:        f.fileScope.Nested(),
		reservedNames: map[string]struct{}{},
	}
}

func (f *File) uniqueImportName(p ImportPath) string {
	name := defaultPackageName(p)
	return f.fileScope.Declare(name)
}

func defaultPackageName(p ImportPath) string {
	_, name := path.Split(p.String())
	name = sanitizeImportName(name)
	return name
}

func sanitizeImportName(name string) string {
	return strings.ReplaceAll(name, "-", "_")
}

type ImportPath string

func (p ImportPath) String() string          { return string(p) }
func (p ImportPath) Ident(name string) Ident { return Ident{Name: name, ImportPath: p} }

type Ident struct {
	Name       string
	ImportPath ImportPath
}

func (i Ident) String() string { return string(i.ImportPath) + "." + i.Name }

// Scope contains Go identifier names from
type Scope struct {
	parent        *Scope
	reservedNames stringSet
}

// Declare reserves unique name for the requested name.
// Returned name will have no conflicts with Go universe scope and previously reserved names.
func (f *Scope) Declare(name string) string {
	baseName := name
	for i := 2; ; i++ {
		if !f.Contains(name) {
			break
		}
		name = fmt.Sprintf("%v%v", baseName, i)
	}
	f.reservedNames.Add(name)
	return name
}

// Redeclare reserves unique name for the requested name, that will shadow same name from parent scope, if it exist.
func (f *Scope) Redeclare(name string) string {
	baseName := name
	for i := 2; ; i++ {
		if !f.reservedNames.Contains(name) && !goUniverseScope.Contains(name) {
			break
		}
		name = fmt.Sprintf("%v%v", baseName, i)
	}
	f.reservedNames.Add(name)
	return name
}

func (f *Scope) Contains(name string) bool {
	if f == nil {
		return false
	}
	if f.reservedNames.Contains(name) {
		return true
	}
	return f.parent.Contains(name)
}

func (f *Scope) Nested() *Scope {
	return &Scope{reservedNames: f.reservedNames.Clone()}
}

type stringSet map[string]struct{}

func (ss stringSet) Clone() stringSet {
	clone := make(stringSet, len(ss))
	for s := range ss {
		clone.Add(s)
	}
	return clone
}

func (ss stringSet) Contains(s string) bool {
	_, ok := ss[s]
	return ok
}

func (ss stringSet) Add(s string) {
	ss[s] = struct{}{}
}

func writeFile(FS afero.Fs, name string, content []byte) error {
	return nil
}

type parsedFile struct {
	ast  *ast.File
	fset *token.FileSet
}

func parseFile(data []byte) (*parsedFile, error) {
	fset := token.NewFileSet()
	file, err := parser.ParseFile(fset, "", data, parser.ParseComments)
	if err != nil {
		return nil, fmt.Errorf("%+v\n%s", err, withLineNumbers(data))
	}
	return &parsedFile{ast: file, fset: fset}, nil
}

func withLineNumbers(data []byte) []byte {
	lineFormat := "%" + fmt.Sprint(linesNumIndent(data)) + "d %s\n"
	s := bufio.NewScanner(bytes.NewReader(data))
	buf := &bytes.Buffer{}
	for i := 1; s.Scan(); i++ {
		_, _ = fmt.Fprintf(buf, lineFormat, i, s.Bytes())
	}
	return buf.Bytes()
}

func linesNumIndent(data []byte) int {
	linesNum := bytes.Count(data, []byte("\n")) + 1
	ident := 1
	maxLinesIdent := 10
	for ; maxLinesIdent <= linesNum; {
		ident += 1
		maxLinesIdent *= 10
	}
	return ident
}

func printFile(f *parsedFile) ([]byte, error) {
	conf := printer.Config{Mode: printer.TabIndent | printer.UseSpaces, Tabwidth: 8} // Config from goimports
	buf := &bytes.Buffer{}
	err := conf.Fprint(buf, f.fset, f.ast)
	if err != nil {
		return nil, err
	}
	return buf.Bytes(), nil
}
